%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Системотехническая часть}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Анализ предметной области}
\subsection{Интерактивное обучение}
Сам термин «обучение» может трактоваться в педагогике достаточно широко. Одно из наиболее удачных определений звучит так: обучение — это двусторонний процесс, осуществляемый учителем (преподавание) и учащимся (учение) \cite{pedDict}.

В данном контексте необходимо разграничить понятия «обучение» и «познание». Так, первичным относительно процесса обучения является отношение «обучающий — обучаемый», которое порождает отношение «обучаемый — учебный материал», относящееся в свою очередь уже к понятию «познание». То есть, ключевым процессом является процесс познания, а обучение — это часть процесса познания, для которой необходимо наличие учителя.

Схематично модель процесса обучения приведена на рисунке \ref{fig:ed-process}

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{ed-process.png}
\caption{Модель процесса обучения}%
\label{fig:ed-process}
\end{figure}

Одним из инструментов, использующихся в образовательном процессе, являются автоматизированные обучающие системы (АОС), к которым можно отнести и образовательные платформы. Согласно Полату, АОС — это совокупность связанных в единое целое технических, программно-алгоритмических, лингвистических информационно-методических средств, предназначенных для автоматизации обучающего диалога, поиска и обработки учебной информации \cite{Polat}.

Принято выделять три составляющих АОС:
\begin{itemize*}
\item теоретическую;
\item тренирующую;
\item контролирующую.
\end{itemize*}

Согласно рисунку \ref{fig:ed-process} АОС должны реализовывать некоторую обратную связь. Эта связь может быть двух типов: внутренняя и внешняя.

Внутренняя обратная связь – это информация, которую обучающийся получает от системы в результате своих действий. Она может иметь как консультирующий (помощь, подсказка и т.п.), так и результативный («верно-неверно», демонстрация правильного результата и т.п.) характер.

Внешняя обратная связь – информация, поступающая от обучающей системы к преподавателю. Пользуясь этой информацией, преподаватель может сам корректировать сценарий обучения.

Наличие этой обратной связи и использование подхода, при котором способ подачи материала корректируется в зависимости от полученной информации об успешности освоения этого материала обучающимися позволяет говорить об использовании интерактивных методов обучения.

Среди множества подобных методов принято выделять следующие \cite{Cholak}:
\begin{itemize*}
\item творческие задания;
\item работа в малых группах;
\item работа в парах;
\item обучающие игры (ролевые игры, имитации, деловые игры и образовательные игры)
\item использование общественных ресурсов (приглашение специалиста, экскурсии);
\item социальные проекты и другие внеаудиторные методы обучения (социальные проекты, соревнования, радио и газеты, фильмы, спектакли, выставки, представления, песни и сказки);
\item разминки;
\item изучение и закрепление нового материала (интерактивная лекция, работа с наглядными пособиями, видео- и аудиоматериалами, «ученик в роли учителя», «каждый учит каждого», мозаика (ажурная пила), использование вопросов, Сократический диалог);
\item обсуждение сложных и дискуссионных вопросов и проблем («Займи позицию (шкала мнений)», ПОПС-формула, проективные техники, «Один — вдвоем — все вместе», «Смени позицию», «Карусель», «Дискуссия в стиле телевизионного ток-шоу», дебаты, симпозиум);
\item разрешение проблем («Дерево решений», «Мозговой штурм», «Анализ казусов», «Переговоры и медиация», «Лестницы и змейки»);
\item кейс-метод;
\item презентации.
\end{itemize*}

\subsection{Геймификация в образовании}

В широком смысле геймификация (от англ. gamification, также игрофикация, геймизация) трактуется как использование игровых подходов и механик для расширения неигрового контекста с целью повышения вовлеченности аудитории \cite{gamification}

Сама идея применения подобной стратегии в образовании не нова: про использование игр в обучении писал еще К.Д. Ушинский, на сегодняшний день по этой теме написано множество статей и диссертаций.

Многие исследователи игры отмечают мобилизацию и активизацию возможностей личности, реализацию ее творческого потенциала, так как игре присущи такие характеристики, как импровизация, дух соперничества, эмоциональная составляющая и удовольствие. Являясь развлечением, разрядкой, она способна перерасти в обучение, в творчество, в моделирование человеческих отношений. Значение игровой технологии невозможно исчерпать и оценить развлекательно - рекреативными возможностями. В том и состоит ее феномен, что являясь развлечением, отдыхом, она способна перерасти в обучение, в творчество, в терапию, в модель типа человеческих отношений и проявлений в труде, воспитании. \cite{gamification-ed}

Кроме того, существует ряд исследований \cite{d1, d2} касательно участия дофамина в запоминании информации. Принимая во внимание, что природа процессов, протекающих в мозге человека, изучена далеко не полностью, можно, тем не менее, прийти к следующему упрощению: 

\begin{enumerate}
\item Информация тем надежнее откладывается в долгосрочную память, чем более эмоционально окрашен был момент ознакомления с ней.
\item Положительные эмоции способствуют усвоению информации больше, чем негативные.
\end{enumerate}

\subsection{Визуальное программирование}

Визуальное программирование - способ создания программы для ЭВМ путём манипулирования графическими объектами вместо написания её текста \cite{VPL}.

В ходе изучения материалов для написания данной работы были замечены некоторые расхождения в определении того, что стоит понимать под термином «визуальное программирование». 

Так, например, некоторые источники относят к визуальному программированию средства WYSIWYG проектирования интерфейсов программ, приводя в пример инструменты, подобные тем, которые предлагает среда разработки программного обеспечения Microsoft Visual Studio. Однако, данный набор средств лишь упрощает и делает более предсказуемым разметку элементов графического интерфейса пользователя и предоставляет фрагменты автогенерируемого кода для ведения дальнейшей разработки на языке текстового программирования. Пример такого инструментария приведен на рисунке \ref{fig:wysiwyg}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{wysiwyg.png}
	\caption{Визуальный редактор форм для Windows-приложения в среде разработки Microsoft Visual Studio 2008}%
	\label{fig:wysiwyg}
\end{figure}

Также на рынке присутствует значительное количество SCADA и SCADA-подобных систем, наиболее известным представителем которых является программный пакет LabVIEW. В целом данная категория аппаратно-программного обеспечения используется в отрасли АСУ ТП для разработки или обеспечения работы в реальном времени систем сбора, обработки, отображения и архивирования информации об объекте мониторинга или управления. Пример программы, разработанной с помощью LabVIEW приведен на рисунке \ref{fig:labview}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{labview.png}
	\caption{Пример описания программы в среде LabVIEW}%
	\label{fig:labview}
\end{figure}

В частности, используемый в LabVIEW язык визуального программирования G основан на парадигме программирования потоков данных. Графическим представлением данного подхода может служить диаграмма потоков данных (Dataflow Diagram, DFD), приведенная на рисунке \ref{fig:dfd}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{dfd.png}
	\caption{Диаграмма потоков данных}%
	\label{fig:dfd}
\end{figure}

Подобно DFD, нотация UML (Unified Modeling Language, унифицированный язык моделирования) также активно используется для моделирования бизнес-процессов и системного проектирования. Пример UML диаграммы вариантов использования продемонстрирован на рисунке \ref{fig:uml}. Существуют решения \cite{uml} для генерации кода из UML в языки текстового программирования, однако, данная практика, подобно рассмотренным выше WYSIWYG-редакторам не может расцениваться как программирование в чистом виде, являясь, тем не менее, зарекомендовавшим себя инструментом моделирования и документирования разрабатываемых систем.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{uml.png}
	\caption{Диаграмма вариантов использования}%
	\label{fig:uml}
\end{figure}

Еще одним примером использования визуального программирования является Blueprint, используемый для взаимодействия с игровым движком Unreal Engine. Пример сценария с использованием этой технологии приведен на рисунке \ref{fig:bp}. Blueprint, в первую очередь, по причине низкой производительности \cite{bptb} не был введен с целью заменить C++, являющийся основным языком программирования, используемым в движке. Его цель - упростить проектирование высокоуровневых взаимодействий с использованием API Unreal Engine. Сравнение производительности Blueprint и C++ приведено в таблице \ref{table:bptb}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{bp.jpg}
	\caption{Пример сценария, описанного на языке Blueprint}%
	\label{fig:bp}
\end{figure}

\begin{table}
% Для таблиц с multirow и multicol необходимо вручную указать сдвиг для caption
\captionsetup{skip=5pt}
\caption{Сравнение производительности Blueprint и C++}
\centering
\begin{tabular}{|r|c|c|c|c|}
\hline
            \multirow{2}{*}{} 
           & \multicolumn{4}{c|}{Количество итераций} \\ \cline{2-5}
Время обработки, мс & 500   & 1000  & 10000 & 100000  \\ \hline
C++		  			& 0    	& 1     & 50    & 4971     \\ \hline
Blueprint \& C++	& 3    	& 5     & 94    & 5437     \\ \hline
Blueprint			& 454   & -     & -     & -      \\ \hline
\end{tabular}
\label{table:bptb}
\end{table}

Наконец, визуальное программирование активно используется в образовательных целях, поскольку позволяет обучающемуся сконцентрироваться непосредственно на проектировании алгоритмов, скрывая от него аспекты, связанные с конкретной платформой и тонкостями реализации транслятора или виртуальной машины. Конкретные примеры из этой категории будут рассмотрены ниже.

Критика визуального программирования применительно к промышленной разработке программного обеспечения сводится, в основном, к следующим моментам \cite{vpl-crit}:

\begin{itemize*}
	\item недостаточный набор средств поддержки программирования (IntelliSense, статические анализаторы и т.п.);
	\item затрудненный контроль версий в силу большого количества параметров, не относящихся непосредственно к функциональности программ (например, положения блоков);
	\item неоправданно большой визуальный объем программы, поскольку в большинстве случаев одна строка кода на текстовом языке программирования эквивалента нескольким блокам в виузальном языке.
\end{itemize*}

Таким образом, можно выделить следующие области применения визуального программирования:

\begin{enumerate*}
	\item SCADA-подобные системы;
	\item обучение программированию;
	\item моделирование процессов.
\end{enumerate*}

\section{Обзор аналогов}
\subsection{Blockly}
Blockly - это библиотека для создания редакторов визуального программирования от компании Google, написанная на javascript \cite{blockly}.

Технология используется в таких проектах, как App Inventor \cite{app-inventor}, Varwin \cite{varwin}, AutoBlocks for Jira \cite{autoblocks} и многих других. Визуально Blockly крайне схож с решением от лаборатории антидисциплинарных исследований Массачусетского технологического института Scratch \cite{scratch}, однако официальной информации об их связи найти не удалось, хотя веб-сайт упомянутого на официальной странице Google Developers \cite{blockly} в числе продуктов, использующих Blockly, App Inventor размещен на поддомене того же Массачусетского технологического института.

Интерфейс приложения, использующего библиотеку Blockly, продемонстрирован на рисунке \ref{fig:blockly}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{blockly.png}
	\caption{Интерфейс приложения, использующего библиотеку Blockly}%
	\label{fig:blockly}
\end{figure}

Blockly написан на чистом javascript, не имеет побочных зависимостей и работает полностью на стороне клиента. Составленная программа может компилироваться в такие текстовые языки, как JavaScript, Python, PHP, Lua и Dart.

Блоки, из которых составляется программа, разделены по категориям:

\begin{itemize*}
	\item логические
	\begin{itemize*}
		\item ветвление (if, else, else if);
		\item сравнение (больше, меньше, равно и т.п.);
		\item логическая операция;
		\item отрицание;
		\item логическая константа;
		\item пустое значение (\lstinline|null|);
		\item тернарный оператор (\lstinline|?:|);	
	\end{itemize*}
	\item циклы
	\begin{itemize*}
		\item for;
		\item while;
		\item for .. in;
		\item break/continue;
	\end{itemize*}
	\item математика
	\begin{itemize*}
		\item числовой литерал;
		\item бинарная арифметическая операция;
		\item унарная арифметическая операция;
		\item тригонометрическая функция;
		\item константа ($\pi$, $\sqrt{2}$ и пр.);
		\item проверка числа на принадлежность подмножеству (четные, нечетные, простые и т.п.);
		\item округление;
		\item математические операции над массивами чисел;
		\item остаток от деления;
		\item случайное число;
	\end{itemize*}
	\item списки
	\begin{itemize*}
		\item объявление коллекции;
		\item длина коллекции;
		\item поиск элемента;
		\item CRUD-операции с элементами;
		\item преобразования к строкам;
		\item сортировка;
	\end{itemize*}
	\item цвет
	\begin{itemize*}
		\item константа;
		\item случайный цвет;
		\item смешение цветов;
		\item цвет из RGB-составляющих;
	\end{itemize*}
	\item переменные
	\begin{itemize*}
		\item объявление;
		\item присваивание;
		\item ссылка на переменную;
	\end{itemize*}
	\item функции.
\end{itemize*}

Недостатки Blockly, в целом, сводятся к общей критике визуальных языков программирования, которая была рассмотрена выше. Кроме того, изначально одинаковые конструкции, например, стандартный цикл for, имеют реализацию в виде различных блоков, что может вызывать неточные ассоциации относительно языков, имеющих широкое распространение в коммерческой разработке, что, однако не является недостатком при выбранном подходе, целью которого видится максимальное абстрагирование от конкретного синтаксиса с целью концентрации на алгоритмах в целом.

\subsection{TRIK Studio}

ТРИК - это кибернетический конструктор отечественной разработки. В комплект входят учебные материалы, контроллер, металлический конструктор, а также программное обеспечение \cite{trik}. Важной частью этого программного обеспечения является среда разработки TRIK Studio. 

Среда предназначена для написания программы для собранного из конструктора робота, а также симуляции выполнения этой программы. Интерфейс редактирования программы приведен на рисунке \ref{fig:trik-edit}, симуляции - на рисунке \ref{fig:trik-run}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{trik-edit.png}
	\caption{TRIK Studio: режим редактирования}%
	\label{fig:trik-edit}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{trik-run.png}
	\caption{TRIK Studio: режим симуляции}%
	\label{fig:trik-run}
\end{figure}

В отличие от компонентов, используемых в библиотеке Blocky, рассмотренной выше, набор блоков, относящихся к алгоритмам, существенно меньше, так как затрагивает алгоритмические абстракции более высокого уровня: начало, конец, цикл, функция, условие и др., зато присутствуют блоки, специфические для аппаратной реализации. Например, поворот робота осуществляется засчет подачи различающихся значений на порты, отвечающие за поведение левого и правого колес робота.

Базовые операции, такие как присваивание, сравнение, арифметические действия осуществляются с помощью текстовых команд, привязанных к соответствующим блокам, что значительно сокращает визуальный объем программы по сравнению с тем же Blockly.

Также при составлении программы разработчик располагает значениями, полученными с датчиков робота, среди которых есть датчики расстояния, освещенности и касания.

Главным достоинством TRIK Studio является относительная универсальность: продукт можно использовать как среду разработки для конкретных аппаратных решений, так и для обучения основам робототехники благодаря встроенной системе симуляции.

Существуют онлайн-курсы \cite{stepik}, которые используют данную среду в качестве программного обеспечения для выполнения домашних заданий. Однако, при таком варианте использования, можно отнести к недостаткам отсутствие бесшовности образовательного процесса, так как для прохождения курса необходимо устанавливать дополнительное программное обеспечение, а также скачивать файлы заданий и загружать результаты выполнения на сервер.

\subsection{Дракон-схемы}

Еще одним примером отечественной разработки в области визуального программирования являются язык ДРАКОН. Пример программы приведен на рисунке \ref{fig:drakon}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{drakon.png}
	\caption{Вычисление ряда Фибоначчи на языке ДРАКОН}%
	\label{fig:drakon}
\end{figure}

По большому счету, цели, стоявшие перед создателями языка, отражены в его названии: ДРАКОН - дружелюбный русский алгоритмический язык, который обеспечивает наглядность.

Язык разрабатывался с целью замены и объединения функциональности других более узконаправленных языков, используемых при проектировании космического корабля «Буран». Простота понимания была одним из ключевых требований. Так, в книге Владимира Паронджанова приводится следующая цитата: «ДРАКОН — легкий язык. Настолько легкий, что разработку многих компьютерных программ для космических ракет на практике ведут не программисты, а инженеры — по принципу «программирование без программистов». Причина частичного отказа от программистов проста. При решении практических прикладных задач инженеры досконально владеют материалом и прекрасно знают постановку задачи. В отличие от них программисты не знают физику процесса и становятся «лишними людьми», без которых в ряде случаев (хотя и не всегда) вполне можно обойтись.» \cite{drakon}

В языке ДРАКОН присутствуют 27 икон, из которых можно сформировать 21 макроикону. Вместе они формируют алфавит языка ДРАКОН, приведенный на рисунке \ref{fig:drakon-alphabet}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{drakon-alphabet.png}
	\caption{Алфавит языка ДРАКОН}%
	\label{fig:drakon-alphabet}
\end{figure}

В 1975 году в работе «Заметки по структурному программированию» Эдсгер Дейкстра предложил четыре принципа структуризации блок-схем \cite{deixtra}:
\begin{enumerate*}
	\item Принцип ограничения топологии блок-схем. Структурная программа должна приводить «к ограничению топологии блок-схем по сравнению с различными блок-схемами, которые могут быть получены, если разрешить проведение стрелок из любого блока в любой другой блок. Отказавшись от большого разнообразия блок-схем и ограничившись данными тремя типами операторов управления (следование, ветвление, цикл), мы следуем тем самым некоей последовательностной дисциплине».
	\item Принцип вертикальной ориентации входов и выходов блок-схем. Имея в виду шесть типовых блок-схем (if-do, if-then-else, case-of, while-do, repeat-until), Дейкстра пишет: «Общее свойство всех этих блок-схем состоит в том, что у каждой из них один вход вверху и один выход внизу».
	\item Принцип единой вертикали. Вход и выход каждой типовой блок-схемы должны лежать на одной вертикали.
	\item Принцип нанизывания блок-схем на единую вертикаль. Типовые блок-схемы следует соединять между собой, не допуская изломов соединительных линий, чтобы выход верхней и вход нижней блок-схемы лежали на одной вертикали.
\end{enumerate*}

Усовершенствованные согласно рекомендациям Эдсгера Дейкстры блок-схемы языка ДРАКОН называются Дракон-схемами.

Программы, составленные на языке ДРАКОН компилируются в заранее выбранный текстовый язык. Допускается использование текстовых команд выбранного языка внутри блоков. Такое сочетание с целевым текстовым языком называется гибридным языком. Примеры таких сочетаний: ДРАКОН-C, ДРАКОН-Java и другие.

\section{Трансляция текстов программ}
В общем смысле понятие трансляции относится не только к языкам программирования, а покрывает собой как формальные, так и естественные языки \cite{trans-dict}.

В информационных технологиях под трансляцией чаще всего понимается преобразование программы, составленной на исходном языке, в программу на целевом языке.

По своему назначению трансляторы могут разделяться на оптимизирующие, тестовые, обратные и т.д., но наиболее известная их классификация - это разделение компиляторы и интерпретаторы.

Компиляторы переводят программу на исходном языке либо в исполняемый код, либо в программу на другом языке. Перевод программы между языками, имеющими схожий уровень абстракции (например, Pascal и C), принято называть транспиляторами.

Интерпретаторы делятся на чистые - читают исходный код и сразу его исполняют - и смешанные - использующие промежуточное представление.

Многие современные языки используют приемы обоих подходов при трансляции.

\subsection{Компиляция}

Принято выделять следующие этапы компиляции:

\begin{enumerate*}
	\item лексический анализ;
	\item синтаксический анализ;
	\item семантический анализ;
	\item оптимизация;
	\item генерация кода.
\end{enumerate*}

На первом этапе лексический анализатор разбивает строку входного текста на отдельные лексемы. Так, например, исходная строка \lstinline|Expires = date + Max-age| может быть представлена в виде следующего потока лексем:

\begin{enumerate*}
	\item ИДЕНТИФИКАТОР "Expires";
	\item ПРИСВАИВАНИЕ;
	\item ИДЕНТИФИКАТОР "date";
	\item ПЛЮС;
	\item ИДЕНТИФИКАТОР "Max-age";
\end{enumerate*}

В зависимости от правил разбора лексем, анализатор может преобразовывать исходный текст в набор правил за один проход, или использовать возвраты применительно к считываемой последовательности символов.

Синтаксический анализатор сопоставляет линейную последовательность лексем, полученных на предыдущем шаге, с набором формальных правил языка. Как правило, результатом работы синтаксического анализатора является синтаксическое дерево (дерево разбора). Пример синтаксического дерева для рассматриваемых входных данных приведен на рисунке \ref{fig:ast}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{ast-cookie.png}
	\caption{Пример синтаксического дерева}%
	\label{fig:ast}
\end{figure}

Результатом работы семантического анализатора является семантическая сеть, представляющая собой ориентированный граф, который отражает смысловое отношение элементов программы. Главными функциями семантического анализатора являются:

\begin{itemize}
	\item ведение таблицы символов;
	\item приведение к явному виду информации, задаваемой в исходной программе неявно;
	\item обнаружение ошибок.
\end{itemize}

Если существует возможность улучшить такие показатели как сокращение времени выполнения программы, повышение производительности, компактность целевого кода и т.п., это происходит на этапе оптимизации.

Примерами оптимизирующих операций могут быть свертки констант, удаление тупиковых записей, разделения или объединения циклов и т.п.

Наконец, получая на вход дерево разбора или абстрактное синтаксическое дерево, кодогенератор преобразует его в набор инструкций целевого языка.

Стоит отметить, что на практике различные этапы, такие как синтаксический и семантический анализ или оптимизация и генерация кода, могут объединяться в один модуль.

\subsection{Интерпретация}

Интерпретация - процесс выполнения инструкций языка. Все интерпретаторы можно разделить на два типа.

Простые интерпретаторы анализируют и сразу же исполняют команды по мере их поступления. Очевидными недостатками использования только простого интерпретатора являются:
\begin{itemize*}
	\item обнаружение ошибок, в т.ч. синтаксических, на этапе непосредственного выполнения программы;
	\item большой объем файлов;
	\item отсутствие оптимизации.
\end{itemize*}

Интерпретаторы компилирующего типа представляют собой систему из простого интерпретатора и компилятора, целевым языком которого является набор инструкций, понимаемых интерпретатором.

Такой подход позволяет использовать все преимущества компиляции, а также дополняет список этих преимуществ возможностью кроссплатформенного использования программ.

Для некоторых языков существуют интерпретаторы, поддерживающие возможность работы в диалоговом режиме (REPL).
\nomenclature{REPL}{Read-eval-print loop — цикл «чтение-вычисление-вывод»}


 
\subsection{Форма Бэкуса-Наура}

Форма Бэкуса-Наура (БНФ) - это формальная система программы синтаксиса, используемая для описания контекстно-свободных грамматик.

Широко используется для описания синтаксиса языков программирования, данных, протоколов и т.д. БНФ подходит как для описания как грамматик, так и регулярного синтаксиса, поскольку регулярные грамматики являются подмножеством контекстно-свободных.

Конструкция БНФ определяет некоторое конечное множество нетерминалов в левой части и правила замены (подстановки) этих нетерминалов другими терминалами или последовательностями символов (терминалами).

Алгоритм проверки на соответствие некоторого текста определенному синтаксису, как правило, выполняется в рекурсивном виде. Кроме того, реализацию такого синтаксиса удобно расширять, поскольку алгоритм легко декомпозируется на отдельные функции, осуществляющие проверки отдельных правил.

Пример описания идентификатора с использованием БНФ приведен в листинге \ref{listings:bnf}

\lstinputlisting[
label={listings:bnf},
caption={Определение идентификатора при помощи БНФ},
]
{listings/bnf.txt}

\section{Event loop}
В подавляющем большинстве случаев на одну страницу веб-браузера выделяется один поток, в котором происходят как перерисовки, так и выполнение пользовательского javascript-кода. Асинхронность выполнения этого кода осуществляется за счет цикла событий (event loop).

Визуальное представление окружения исполнения javascript, состоящее из стека вызова, очереди и кучи, представлено на рисунке \ref{fig:jsre}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{jsre.png}
	\caption{Визуальное представление окружения исполнения javascript}%
	\label{fig:jsre}
\end{figure}

Куча - это неструктурированная область памяти, хранящая объекты.

При вызове функции создается контекст ее выполнения и помещается в стек вызова. Когда функция возвращает результат, ее контекст удаляется из стека.

При пустом стеке вызова проверяется очередь задач: если она не пуста, первая задача извлекается из очереди и обрабатывается. Обработка задачи состоит в вызове  ассоциированной с ней функции с параметрами, записанными в этой задаче. Как обычно, вызов функции создаёт новый контекст выполнения и заносится в стек вызовов. \cite{mdn-el}

Наиболее часто используемыми функциями для работы с очередью задач являются \lstinline|setTimeout| и \lstinline|setInterval|, которые принимают первым аргументом функцию обратного вызова, а вторым - время в миллисекундах, через которое данная функция будет помещена в очередь задач. По вышеописанным причинам, \lstinline|setTimeout| и \lstinline|setInterval| могут гарантировать только минимальное время через которое функция будет вызвана.


\section{Canvas}

Для отображения в браузере графической информации можно пользоваться DOM-элементами, однако при определенном уровне динамики это становится слишком неэффективно, поскольку операции с ними требуют внесения изменений в DOM-дерево и перерисовки композитных слоев, на которых они расположены. Для тех случаев, где удобно работать с визуальным представлением как с набором точек, существует элемент \lstinline|<canvas>|.

Взаимодействие с графикой происходит через объект контекста, получаемого с помощью метода \lstinline|getContext(contextType, contextAttributes)|, принимающего первым параметром тип контекста. Возможные варианты \cite{get-context}:
\begin{itemize*}
	\item 2d - двумерный контекст;
	\item webgl - трехмерный контекст, доступен в браузерах, реализующих WebGL первой версии (OpenGL ES 2.0);
	\item webgl2 - трехмерный контекст, доступен в браузерах, реализующих WebGL второй версии (OpenGL ES 3.0);
	\item bitmaprenderer - обеспечивает только функции для замены содержимого холста с заданным \lstinline|ImageBitmap|.
\end{itemize*}

Двумерный контекст предоставляет возможность рисования таких примитивов, как прямоугольник, путь, кривая Безье и дуга, визуальное представления которых обеспечивается с помощью выбора цвета заливки и обводки. Кроме того, существует ряд методов реализующих матричные трансформации контекста, а также отрисовку набора пикселей, полученных, например, из растрового изображения.

К элементу \lstinline|<canvas>| применимо большинство DOM-событий, таким образом можно получать информацию о действиях пользователя, например, движения указателя мыши над элементом.

Базовая поддержка Canvas составляет на данный момент 98.87\% среди всех веб-браузеров \cite{caniuse-canvas}.

%\blindtext
%It is of great importance that you use correct references in your dissertation.
%Resent studies show that it can increase the chances of successful defense
%by as much as 3,17 percent~\cite{russian, ANTLR, java-book}.
%
%\begin{table}[H]
%	\caption{Название таблицы}
%	\begin{center}
%		\begin{tabular}{|l|l|}
%			\hline
%			top left & top right\\ \hline
%			bot left & bot right\\ \hline
%		\end{tabular}
%		\label{tabular:tab_examp}
%	\end{center}
%\end{table}
%
%
%\Blindtext
